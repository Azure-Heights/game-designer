
COMPILER_PATH = "scripts/AutoCompile.jar"
OUT_PATH = "output/generated.lud"
IN_PATH  = "data/ludii/lud/math/Mastermind.lud"


# +-- Initially generated by ChatGPT - 3/17/25

import os
import subprocess
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

class AgentState(TypedDict):
    ludeme: str  # The generated Java code
    error_message: str | None  # Compilation error message

# Function to save Java code to a file
def save_code_to_file(state: AgentState) -> str:
    filename = OUT_PATH
    with open(filename, "w", encoding="utf-8") as f:
        f.write(state["ludeme"])
    return filename

# Function to compile Java code and return success/failure
def compile_code(state: AgentState) -> AgentState:
    filename = save_code_to_file(state)
    result = subprocess.run(["java", "-jar", COMPILER_PATH, filename], capture_output=True, text=True)
    
    if "Success" == result.stdout:
        return {"ludeme": state["ludeme"], "error_message": None}  # Compilation successful
    else:
        return {"ludeme": state["ludeme"], "error_message": result.stderr}  # Compilation failed

# Function to check if compilation was successful
def is_compilation_successful(state: AgentState) -> bool:
    return state["error_message"] is None

# Define the LangGraph workflow
graph = StateGraph(AgentState)
graph.add_node("compile", compile_code)
graph.add_edge(START, "compile")
graph.add_edge("compile", END)

workflow = graph.compile()

# --+


if __name__ == "__main__":

    with open(IN_PATH) as fin:
        ludeme = fin.read()

    initial_state = {"ludeme": ludeme, "error_message": None}
    outcome = workflow.invoke(initial_state)

    print("Final State:", outcome)

